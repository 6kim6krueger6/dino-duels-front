{"version":3,"file":"static/js/122.458b50c4.chunk.js","mappings":"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","sources":["../node_modules/@simplewebauthn/browser/dist/bundle/index.js"],"sourcesContent":["/* [@simplewebauthn/browser@9.0.1] */\nfunction utf8StringToBuffer(value) {\n    return new TextEncoder().encode(value);\n}\n\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(creationOptionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...creationOptionsJSON,\n        challenge: base64URLStringToBuffer(creationOptionsJSON.challenge),\n        user: {\n            ...creationOptionsJSON.user,\n            id: utf8StringToBuffer(creationOptionsJSON.user.id),\n        },\n        excludeCredentials: creationOptionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction bufferToUTF8String(value) {\n    return new TextDecoder('utf-8').decode(value);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(requestOptionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (requestOptionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = requestOptionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...requestOptionsJSON,\n        challenge: base64URLStringToBuffer(requestOptionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll('input[autocomplete$=\\'webauthn\\']');\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToUTF8String(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n"],"names":["utf8StringToBuffer","value","TextEncoder","encode","bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","undefined","window","PublicKeyCredential","toPublicKeyCredentialDescriptor","descriptor","id","transports","isValidDomain","hostname","test","WebAuthnError","message","code","cause","name","Error","identifyRegistrationError","error","options","publicKey","signal","AbortSignal","authenticatorSelection","requireResidentKey","userVerification","pubKeyCredParams","filter","param","type","effectiveDomain","location","rp","user","byteLength","WebAuthnAbortService","this","controller","abortError","abort","newController","AbortController","attachments","toAuthenticatorAttachment","attachment","indexOf","startRegistration","creationOptionsJSON","challenge","excludeCredentials","map","createNewAbortSignal","navigator","credentials","create","credential","rawId","response","getTransports","responsePublicKeyAlgorithm","getPublicKeyAlgorithm","warnOnBrokenImplementation","responsePublicKey","getPublicKey","_publicKey","getAuthenticatorData","responseAuthenticatorData","attestationObject","clientDataJSON","publicKeyAlgorithm","authenticatorData","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","methodName","console","warn","bufferToUTF8String","TextDecoder","decode","browserSupportsWebAuthnAutofill","globalPublicKeyCredential","isConditionalMediationAvailable","Promise","resolve","identifyAuthenticationError","rpId","startAuthentication","requestOptionsJSON","useBrowserAutofill","allowCredentials","document","querySelectorAll","mediation","get","userHandle","signature","platformAuthenticatorIsAvailable","isUserVerifyingPlatformAuthenticatorAvailable"],"sourceRoot":""}